## RestTemplte
![img.png](img.png)

## SpringCloud微服务
 第一个项目 目前有消费者(调用生产者的业务) 和 生产者(提供业务接口实现类)
 并且两个公用一个实体类(Domain) 所以和Dubbo很像
 - 生产者 消费者 接口工厂(存放实体类 Dao Service接口)

## SpringCloud微服务流程
 1 创建三个文件
   消费者 继承接口工厂
   生产者 继承接口工厂
   接口工厂
 2 实现接口工厂中的接口 
 3 实现消费者的api
 4 创建消费者
 5 在消费者中创建一个Config创建RestTemplate对象在Spring容器中
6  通过RestTemplate对象 请求生产者的api 并且获取结果
 
  与 Dubbo非常像

## 以上为基础部分


## 以下为初级部分

## Eureka 基础(服务注册与发现) 已停止更新
 就是一个服务注册 可以管理于服务之间的关系（a服务 调用 b服务）
通过Eureka 可以实现 服务调用 负载均很 容错 实现服务发现与注册

# 什么是服务注册
每一个微服务 通过注册的方式 将自己的信息放在注册服务器上 消费者可以直接调用上面的注册的方法 
 也就类似于 Dubbo+ZooKeeper 
  Dubbo
  先注册生产者到spring.dubbo.registry:zookeeper://localhost:2181
  然后通过  spring.dubbo.server = true 来声明为当前的applicaton.name 为生产者
  在实现类 中 通过 @Service(InterFace=...) 来暴露要提供给消费者的对象

  消费者 直接监听spring.dubbo.registry:zookeeper://localhost:2181
  然后通过@Refrence注解获取对应的对象
  
 Dubbo 成员
      
           注册中心          接口工厂
    消费者           生产者

 
## Eureka 的组件
  Eureka Server 提供服务注册服务 
    每一个微服务节点 通过配置启动后 会在EurekaServer中进行注册 这样 EurekaServer 中的服务注册表中将会存储所有可用的服务节点的信息
 服务节点 的信息 可以在信息界面中直观的看到

  EurekaClient 通过注册中心进行访问
是一个java的客户端  简化Server的操作
  应用启动后 将会向Server发送心跳(默认为30s)

# Eureka 注册中心的搭建
# 1写配置
[- 端口]
server.port=7001
[- eureka名称]
eureka.instance.hostname=localhost
[- 该项代表当前的类就是服务注册中心]
eureka.client.register-with-eureka=false
[- 该项代表当前的类就是服务注册中心 所以不用检索服务]
eureka.client.fetch-registry=false 
[- 该地址相当于 Dubbo服务注册要使用的地址]
eureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka
  
# 2 写注解
@SpringBootApplication
[@EnableEurekaServer]
public class EurekaApplication {

    public static void main(String[] args) {
        SpringApplication.run(EurekaApplication.class, args);
    }

}

## 添加生产者到注册中心
添加依赖
  <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>

[@EnableEurekaClient] 注解 标识当前的类是一个服务消费/提供者

配置
# Eureka
# 是否注册进Eureka
eureka.client.register-with-eureka=true
# 是否订阅
eureka.client.fetch-registry=true
# 注册的端口
eureka.client.service-url.defaultZone=http://localhost:7001/eureka


## 注册成功后
![img_1.png](img_1.png)

微服务的名称 就是 配置文件的spring.application.name的值

## Eureka 集群
互相注册 互相守望
## 集群 配置地址为另一台主机 主机间相互注册
                                      地址为另一台主机的地址
eureka.client.service-url.defaultZone=http://eureka2:5000/eureka

## 将消费者 注册进集群

                                         // 所有注册服务器的地址
eureka.client.service-url.defaultZone =http://localhost:8100/eureka,http://localhost:5000/eureka

## 提供者集群
  
同样 通过eureka.client.service-url.defaultZone =http://localhost:8100/eureka,http://localhost:5000/eureka
        指定多台服务器 每一个消费者用application.name 来区分功能 比如pay功能 可以有多台提供者提供 也就是applicaiton.name可以重复
                              用 port 来区分 功能里面的服务器 比如有两台服务器 都是pay功能(application-name都为pay) 端口分别为 8001 8002 则消费者访问pay功能时 就会使用轮询的方法来 进行负载均衡  
## 消费者消费
//    查看id

@RequestMapping("/consumer/serch/{id}")
public PayMent Seach(@PathVariable Integer id){
                                     // 通过微服务名称调用
return restTemplate.getForObject("http://PAYMENT"+"/serch/"+id,PayMent.class);
}


@LoadBalanced 注解开启负载均衡 给RestTemplate 赋予负载均衡的功能
@Bean
@LoadBalanced
public RestTemplate get(){
return new RestTemplate();
}


调用后 Eureka 会通过微服务名称 找到所有的服务提供者 并且自动轮询 也就做到了负载均衡

## 微服务别名
 
eureka.instance.instance-id=pay8002

## 显示ip地址在后台
eureka.instance.prefer-ip-address=true

## Day2 复习
 1 配置两个 Eureka注册中心 @Server 并且组为集群 互相监视 名字为 eureka1 eureka2 端口为 7001 7002
   @Client
 2 配置一个消费者通过RestTemplate对象进行消费 ip是微服务名! 端口为800
 3 配置两个消费者 都是Pay服务 端口为8001 8002 并且组为集群 
 4 开启负载均衡
 5 修改微服务别名
 6 显示微服务ip地址

## Day2复习成功


## Eureka 自我保护
 如果一个微服务 在一段时间内 没有心跳反应 则Eureka则会开启自我保护功能


# 如何禁止 自我保护
#  关闭自我保护
eureka.server.enable-self-preservation=false
# 心跳检查时间
eureka.server.eviction-interval-timer-in-ms=2000
# 心跳间隔检查 默认30
eureka.instance.lease-renewal-interval-in-seconds=1
# 服务端多少秒没接收到消息后自动删除微服务 默认90
eureka.instance.lease-expiration-duration-in-seconds=2

## zookeeper
与Eureka一致
application-name 还是微服务名称
spring.cloud.zookeeper.connect-string : zookeeper地址

启动类使用@EnableDiscoveryClient

## 运行zookeeper.cli
输入指令
ls /services/微服务名   可以获取一个哈希值 用这个哈希值可以获取微服务的信息
get /services/微服务名/获取的哈希值 查看微服务消息
Eureka 不能与 zookeeper 依赖共存

#  Day3 Pass (zookeeper Eureka自我保护机制)
## Day4 复习 Zookeeper 


##  什么是Consul?
与Eureka和Zookeeper一样 都是服务注册中心

服务注册与发现 检查 KV键值队 可视化Web页面
、
启动类使用@EnableDiscoveryClient
流程

POM
配置类
提供者
消费者

# 下载Consul
 下载完毕后 是一个压缩包 解压后是一个exe文件 在文件夹中打开 cmd窗口
 运行 
  consul --version 可以查看版本
  运行 consul agent -dev 后 可以在localhost:8500 访问后台界面


## 三个注册中心的异同
zookeeper  java 无界面    CP
Consul     go      有    CP
Eureka     java    有    AP

CAP: C 强一致性  A 可用性 P 分区容错性

## Ribbon负载均衡

Ribbon是一款实现 客户端（消费者） 负载均衡的工具 

Ribbon和nginx的区别

Ribbon 是一个客户端的负载均衡软件 在调用 微服务接口的时候 会在注册中心（eureka）上获取注册信息的提供者列表之后 缓存到JVM本地 从而在本地实现RPC远程服务调用技术
Nginx 是一个服务器的负载均衡软件 客户端的所有请求都会经过nginx的处理 从而实现负载均衡
RPC 远程调用技术 request-response 
# 架构
![img_2.png](img_2.png)
# eureka 与 ribbon
eureka的依赖中 已经包含了ribbon
# ribbon与RestTemplate
restTemplate有很多的方法
如
restTemplate.getObject()  // 获取的是响应体中数据转为的对象 可以理解为json 返回对象为CommResult<内容的对象>
restTemplate.getEntity() // 获取响应体和响应头 状态码 等等   返回对象为CommResult<内容的对象>
# 自定义负载算法
  1 不能放在componentScan的包中
 2 创建一个类 并且标记注解configuration
    用@Bean 来创建一个IRule类 具体实现类 可以查看
 3 消费者类上 添加一个注解 @RibbonClient(name="微服务名",configuration=类.class)
# IRules实现类
![img_4.png](img_4.png)
# ribbon的负载均衡 轮询算法
![img_3.png](img_3.png)
# Day4 
 创建两台Eureka注册中心 并注册为集群 互相守望
 创建两个服务提供者
 创建一个消费者 
 通过Ribbon 手写轮询算法
Provider 不要设置Host
Consumer 可以设置 
@LoadBalanced 必须写 如果要使用集群

## CAS CompareAndSet
    AtomicInteger atomicInteger = new AtomicInteger(0);

compareAndSet(当前值,期望值) 如果atomic的值等于当前值 就会更新为期望值 否则不更新 这也叫做 CAS

## 自定义轮询算法
1  创建一个接口 实例方法参数为list<ServiceInstance>   是一个列表 通过DiscoryClient.getInstances方法获取
   返回值为ServiceInstance对象 该对象就是Eureka服务
2  在实现类中 通过AtomicInteger对象和CAS思想来判断访问次数 因为只有该对象可以在高并发下保证数据安全
3  通过 访问次数%服务器数量(list<ServiceInstance>.size()) 来获取下一台的下标
4  通过下标 来调用serviceInstances.get(index); 来获取ServiceInstance对象
5  控制器对象 通过使用            uri = s.getUri(); 获取要轮询的服务器的url地址
6  return restTemplate.getForObject(uri + "/create/" + Detail, Map.class); 通过url访问微服务


 
# OpenFeign
OpenFeign 整合了ribbon和restTemplate 可以简化消费者的开发流程

# OpenFeign的思想
 与Dubbo非常的类似 都是面向接口调用 也就是调用Service接口 通过接口来实现调用
  Dubbo暴露Service的注解使用的是@Service 接收用的是@Refrence
  OpenFeign用@OpenFeign暴露  

## OpenFeign流程
1 添加@EnableFeignClient注解到启动类

2 创建一个Service接口 并且绑定微服务 和要使用的方法
@Component
//选取调用哪一个微服务
@FeignClient(value = "PAYMENT")
public interface PayService {
//    调用微服务的哪一个方法
@RequestMapping("/create/{Detail}")
public ReturnJson Create(@PathVariable(value = "Detail") String Detail);
}

3  创建一个Controller 并且通过之前的接口 来调用服务提供者的方法

@RestController
public class IndexController {
@Autowired
PayService payService;
@RequestMapping("/create/{Detail}")
public ReturnJson Create(@PathVariable String Detail){
return payService.Create(Detail);
}
}

## OpenFeign 超时控制
请求时间超过1s后 报错

## 设置超时
feign.httpclient.connection-timeout=5000

# OPenFeign日志
NONE 默认的 不显示日志
BASIC 仅记录请求方法 URL  状态码 执行时间
HEADERS 包括BASIC的信息 还有请求和响应头
FULL 包括HEADERS的信息 并且还有 请求和相应的正文及元数据

写一个配置类 并且定义Logger
@Configuration
public class FeignConfig {
@Bean
Logger.Level feign(){
return Logger.Level.FULL;
}
}

配置类中
logging.level.com.misaka.openfeignconsumer:debug


# Day5 复习 Pass
1 自写Ribbon轮询算法
    -  创建一个接口 实例方法参数为list<ServiceInstance>   是一个列表 通过DiscoryClient.getInstances方法获取
       返回值为ServiceInstance对象 该对象就是Eureka服务
    -  在实现类中 通过AtomicInteger对象和CAS思想来判断访问次数 因为只有该对象可以在高并发下保证数据安全
    -  通过 访问次数%服务器数量(list<ServiceInstance>.size()) 来获取下一台的下标
    -  通过下标 来调用serviceInstances.get(index); 来获取ServiceInstance对象
    -  控制器对象 通过使用            uri = s.getUri(); 获取要轮询的服务器的url地址
    -  return restTemplate.getForObject(uri + "/create/" + Detail, Map.class); 通过url访问微服务

2 复习OpenFeign的使用 
   - 开启OpenFeign
   - 创建一个业务接口 并且通过注解 监听对应eureka的微服务提供者 并且绑定对应的方法
   - 通过Controller调用接口方法

结果
经测试 OpenFeign的默认算法为轮询

# Hystrix 断路器 服务降级 (中级)
当微服务项目达到一定的大小时 一定会出现 A服务要调用多个服务 如果其中一个服务出现问题
那么服务就会雪崩 
 那么就要使用断路器 当某一个单元发生故障时 向调用方返回一个符合 预期 可处理的备选响应(FallBack) 而不是长时间的等待或抛出异常

# Hystrix 服务降级
如果服务器忙 就返回一个请稍后再试

 - 那些情况会服务降级 
   1 程序运行异常 
   2 超时
   3 服务熔断触发服务降级
   4 线程池/信号量打满也会导致降级
   
# Hystrix 服务熔断
 类比保险丝
  达到最大的服务访问后 直接拒绝访问 拉闸限电 然后调用服务降级的方法
 就是保险丝
# Hystrix 服务限流
 秒杀高并发等操作 严禁一窝蜂的请求 大家排队 一秒钟N个 有序进行(消息队列) 

## 通过jmeter模拟高负载环境 测试后发现消费者消费服务时 要等待时间 

## 解决方法
  - 对方的服务8001超时 调用者80不能一直等待 必须有服务降级
  - 对方的服务宕机了 调用者不能一直等待 必须要有服务降级
  - 对方的服务Ok 调用者自己出故障或有自我要求 自己的等待时间小于服务提供者 自己(80)处理降级

# 降级的方法
@HystrixCommand(fallbackMethod="服务降级方法名",commandProperties={
@HystrixProperties(name="属性",value="直“)
}) 注解 

@EnableCircuitBreaker //主启动类 的注解 
## 服务降级的方法必须返回值 必须与服务方法一致

## 限制响应时长的配置
@HystrixCommand(fallbackMethod ="fallback" ,commandProperties = {
@HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000") //最长响应时间 超过就使用服务降级方法
})
## 处理降级服务的维度
 1 先处理服务提供者自身可能的问题 例如自己的最大响应时长 否则就服务降级
 2 还可以对客户端进行降级保护
    - 开启feign.hystrix.enabled:true 属性
    - 主启动类 添加开启hystrix的注解
    - 业务类添加  并添加服务降级的方法 
 @HystrixCommand(fallbackMethod ="fallback" ,commandProperties = {
 @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000") //最长响应时间 超过就使用服务降级方法
 })
    - 客户端就比服务端多了一个开启yml配置的步骤 其他一致

## 优化
 - 服务端
 如何避免 兜底方法和业务方法 在一起 避免耦合度高
  例如一种 所有的方法公用的降级方法 
 @DefalutPeoperties(defaultFallback="") 放在对应的控制器类上面
 要使用默认方法的 就是用@HystrixCommad 注解  不加value就是使用defalut
   
 - 消费端
 - 用一个类实现业务方法(openFeign的业务接口)接口 重写的方法体 也是就是fallback
 - @FeignClient(value = "PAY",fallback = PayServiceFallBack.class) 指定fallback的类
    - 不需要写@HystrixCommand标签
 - 服务器就算是宕机了 也会调用服务降级的方法

## 熔断使用的代码
//服务熔断
@HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback",commandProperties = {
@HystrixProperty(name = "circuitBreaker.enabled",value = "true"),  //是否开启断路器
@HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),   //请求次数
@HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"),  //时间范围
@HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"), //失败率达到多少后跳闸
})
public String paymentCircuitBreaker(@PathVariable("id") Integer id){
if (id < 0){
throw new RuntimeException("*****id 不能负数");
}
String serialNumber = IdUtil.simpleUUID();

    return Thread.currentThread().getName()+"\t"+"调用成功,流水号："+serialNumber;
}
public String paymentCircuitBreaker_fallback(@PathVariable("id") Integer id){
return "id 不能负数，请稍候再试,(┬＿┬)/~~     id: " +id;
}


## 服务熔断
熔断机制 
当一个服务不可以或者响应时间过长时 就会进行服务降级 进而熔断该节点的微服务调用 快速的返回错误的响应信息
当检查到链路恢复时 则恢复调用

## 熔断机制
@HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback",commandProperties = {
@HystrixProperty(name = "circuitBreaker.enabled",value = "true"),  //是否开启断路器
@HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),   //请求次数
@HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"),  //时间范围
@HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"), //失败率达到多少后跳闸
})
 如果在一个时间内 连续错误n个请求 则会自动熔断 全部返回fallback 包括正常请求
 如果正常请求的数量又变多了 则会取消熔断 恢复正常

## Day7 复习 
 Hystrix熔断(8001) fallback机制(8002)
 消费者使用openFeign的服务降级保护机制 写一个业务接口实现类.......
 
项目结构
 1 两台eureka注册中心 7001 7002
 2 两个提供者 8001 8002
 3 一个消费者 800


 

## 统一处理fallback 结构
@Component
@DefaultProperties(defaultFallback = "fallback")   //[设置全局的fallback]
public class PayServiceImpl implements PayService {
      @Override
      @HystrixCommand(commandProperties = {   //[设置属性]
         @HystrixProperty(name = "circuitBreaker.enabled",value = "true"),  //是否开启断路器
         @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),   //请求次数
         @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"),  //时间范围
         @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"), //失败率达到多少后跳闸
      })
      public String pay(int id) {
          if(id<0){
          throw new RuntimeException("错误呐");
          }else
          return "成功";
      } 
      public String fallback(){
          return "fallback";
      }
   }
## 消费者端的加固
@Component
@FeignClient(value = "PAY",fallback = OpenFeignFallback.class) //指定实现类 其中所有的重写方法就 就是对应的fallback
public interface OpenFeign {
    @RequestMapping("/pay/{id}")
    public String pay(@PathVariable("id") int id);
}


## 服务熔断小总结
     @HystrixProperty(name = "circuitBreaker.enabled",value = "true"),  //是否开启断路器
         @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),   //请求阈值
         @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"),  //快照时间窗
         @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"), //失败率
涉及到熔断的三个重要参数 快照时间 请求总数 错误百分比

1 快照时间 断路器是否打开需要统计一些请求和错误数据 而统计的时间范围 就是快照时间窗 默认为最近的10s
2 请求总数阈值 在快照时间内 必须满足请求总数 阈值才有资格熔断 默认为20 意味着在10s内 如果该hystrix命令的调用次数不足20次
即使所有的请求超时或失败 断路器都不会启动
3 错误百分比 在请求总数在快照时间中超过了阈值 比如发生了30次调用 如果在30次中 失败了15次
也就是50%失败率 在默认情况下(50%) 断路器就会开启

## hystrix 服务监控
![img_5.png](img_5.png)

## hystrix可视化 界面
该界面 是单独的一个监控者 所以要创建一个 并且 添加一个依赖

    <!--新增hystrix dashboard-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>
        </dependency>

监控者加注解
@EnableHystrixDashboard
监控者地址 localhost:xxx / hystrix
http://localhost:802/hystrix


所有Provider微服务提供类（8001/8002/8003）都需要监控依赖配置
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>


并且在主启动类上面写
@Bean
public ServletRegistrationBean getServlet(){
HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet();
ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet);
registrationBean.setLoadOnStartup(1);
registrationBean.addUrlMappings("/hystrix.stream");  // 监控地址的后缀 xxx:xxx/xxx  http://localhost:7001/hystrix.stream
registrationBean.setName("HystrixMetricsStreamServlet");
return registrationBean;
}
 

## 监控图解
![img_6.png](img_6.png)

## GateWay Zuul(已过气) 网关
 - GateWay 是什么?
  

## GateWay 三大核心概念
 - 路由
  路由是构建网关的基本模块 它由ID 目标URI 一系列的断言和过滤器组成 如果断言为true 则匹配该路由
 - 断言
  开发人员可以匹配HTTP请求的所有内容 (请求头 请求参数 ) 如果请求与断言相匹配 则进行路由
 - 过滤
  不是拦截器!!!
    指的是Spring框架中GateWayFillter的实例 使用过滤器 可以加强请求 也就是在请求被路由接收或之后 进行对请求的加强 例如
    -- 获取前
       权限校验 流量监控 日志输出 协议转换(http->ws)
    -- 获取后
       响应内容 响应头的修改 日志的输出 流量监控
   

## 网关的作用 
将真正的服务端口例如8001 上面套上 一层网关的端口 所有的请求必须通过网关撒选通过

## 网关的配置



# 路由的id 没有规则但是必须为唯一值 最好为服务名
#http://localhost:7001/pay/1 给这个网址赋予一个网关
spring.cloud.gateway.routes[0].id=gateway-service
#路由会访问的路径
spring.cloud.gateway.routes[0].uri=http://localhost:7001
#会访问的uri 可以使用通配符
spring.cloud.gateway.routes[0].predicates[0]=Path=/pay/**

routes是一个list 可以配置多个路由


## ! GateWay的坑
Parameter 0 of method modifyResponseBodyGatewayFilterFactory in org.springframework.cloud.gateway.config.GatewayAutoConfiguration required a bean of type 'org.springframework.http.codec.ServerCodecConfigurer' that could not be found.
该报错是因为 GateWay底层使用的是WebFlux 而不是Web 所以要把 spring-boot-starter-web 依赖删除 如果要使用web服务 则要使用webflux依赖

## 解决
 <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <!-- Maven整个生命周期内排除内置容器，排除内置容器导出成war包可以让外部容器运行spring-boot项目-->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>

## 通过网关访问
http://localhost:9527/pay/-1    // 可以掩盖原端口号
## 通过编码跳转网关路由
创建一个COnfig类 里面用@Bean实例化一个RouteLoctor对象 并且有一个参数RouterloctorBuilder

@Configuration
public class Config {
      @Bean
      public RouteLocator routeLocator(RouteLocatorBuilder routeLocatorBuilder) {
          RouteLocatorBuilder.Builder builder = routeLocatorBuilder.routes();
          // id                   // 路由               //映射路径 http://baidu.com/hello
          builder.route("test", r -> r.path("/hello").uri("https://baidu.com")).build();
          // id                   // 路由               //映射路径 http://localhost:7001/pay/**
          builder.route("testx", r -> r.path("/pay/**").uri("https://localhost:7001")).build();
          return builder.build();
    }
}


## Day8 Pass
复习 hystrix 服务降级(消费端 服务端) 熔断(消费端 服务端) 图形化显示(9001)
复习 gateWay 路由配置 properties配置 路由代码设置\


## GateWAY的动态ip设置
# 开启微服务名访问功能 以便于服务集群的使用
spring.cloud.gateway.discovery.locator.enabled=true
 - 然后                                            //使用微服务名字 并且协议为lb
   route.route("Pay", r -> r.path("/pay/**").uri("lb://pay")).build();

## Predicate
第二大特性 断言
设置多个断言
spring.cloud.gateway.routes[0].predicates[0]=Path=/pay/**
spring.cloud.gateway.routes[0].predicates[1]=After=2022-01-16T19:04:42.802+08:00[Asia/Shanghai]

    // Path也是断言的一种
spring.cloud.gateway.routes[0].predicates[0]=Path=/pay/**
断言的类型 通过之前的知识点知道 一个网关的请求 必须要通过断言的审核才能进入到路由转发环节



After 在指定的时间之后 断言为true
如
spring.cloud.gateway.routes[0].predicates[0]=After=2022-01-16T19:04:42.802+08:00[Asia/Shanghai]


Before 时间与After 同类型 之前
Between 时间与After 同类型 之间


Cookie 检查请求是否带上cookie 或者cookie是否正确 例如 该cookie必须有对应的key
 Cookie = username,misaka   要求cookie必须要有一个key 为username value为misaka
spring.cloud.gateway.routes[0].predicates[2]=Cookie=username,misaka

Header 请求头的断言
 Header=hello.xx   请求头中必须含有hello 属性 值为xx 值可以为正则表达式
Host
  域名 localhost。。。
Method
  方法 Get..
Path
  路径 /pay/** 
Query
  get参数 key=value value可以为正则表达式
ReadBody
RemoteAddr
Weight
CloudFoundryRouteService

## Filter
三大特性 过滤器

生命周期 
 pre post

种类
 GateWayFilter
 GlobalFilter

自定义过滤器
 1 实现两个接口 GlobalFilter,Ordered

@Component
public class Filter implements GlobalFilter, Ordered {
     @Override
     public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
            System.out.println("***come in Filter");
            //        获取请求的参数
            String uname= exchange.getRequest().getQueryParams().getFirst("uname");
            if(uname==null){
            System.out.println("为空");
            //            设置状态码
            exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE);
            //            返回结果
            return exchange.getResponse().setComplete();
            }
            //        正常返回
            return chain.filter(exchange);
     
         }
@Override
     //    加载过滤器实现类类的顺序 值越小 优先级越高 类似加权重
     public int getOrder() {
           return 0;
     }
}



## Day9 Pass
复习


dashborder
熔断
fallback
多个断言设置 
filter

## Config 分布式配置中心
 微服务意味着 要将单体应用的业务拆分成一个个的子服务 每一个服务的粒度较小 因此系统中会出现大量的服务 由于每一个服务
都需要必要的配置信息才能运行 所以一套集中式 动态的配置管理是必不可少的
 springCloud 提供了 ConfigServer 来解决这个问题 我们每一个微服务自己带着一个application.Yml 上百个的配置文件管理就会十分的麻烦 例如mysql的迁移》。。
Config也是一个微服务(也要注册到注册中心中) 只不过是提供服务配置的微服务


 
一般和Git一起使用


#步骤
 1 创建一个仓库在github里面 专门用于存储config的yml文件
 2 创建 Yml并且配置
   GitHub的仓库名字
   spring.cloud.config.server.git.uri=
   配置文件目录 是一个数组  config文件夹
   spring.cloud.config.server.git.search-paths[0]=config
   读取的分支
   spring.cloud.config.label=master

 


## Bus